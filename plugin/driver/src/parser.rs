// Code generated by build.rs DO NOT EDIT.
// VERSION: 1.5.0.0
// Maintainers: ["zhanglei.sec@bytedance.com"]
use crate::cache::{ArgvCache, FileHashCache};
use anyhow::*;
use clru::CLruCache;
use coarsetime::Clock;
use fnv::FnvBuildHasher;
use ipnet::{Ipv4Net, Ipv6Net};
use iprange::IpRange;
use log::*;
use plugin::*;
use serde::Serialize;
use users::{Users, UsersCache};

#[derive(Debug, Serialize)]
struct LoadModule<'a> {
    pgid_argv: &'a str,
    exe_hash: &'a str,
    sessionid: &'a str,
    pid: &'a str,
    username: &'a str,
    ko_file: &'a str,
    nodename: &'a str,
    run_path: &'a str,
    uid: &'a str,
    sid: &'a str,
    comm: &'a str,
    tgid: &'a str,
    exe: &'a str,
    pid_tree: &'a str,
    pns: &'a str,
    root_pns: &'a str,
    ppid: &'a str,
    pgid: &'a str,
    timestamp: &'a str,
    data_type: &'a str,
    argv: &'a str,
    ppid_argv: &'a str,
}

#[derive(Debug, Serialize)]
struct CreateFile<'a> {
    sip: &'a str,
    timestamp: &'a str,
    pgid: &'a str,
    username: &'a str,
    pid: &'a str,
    exe_hash: &'a str,
    comm: &'a str,
    sport: &'a str,
    pgid_argv: &'a str,
    pid_tree: &'a str,
    root_pns: &'a str,
    uid: &'a str,
    exe: &'a str,
    nodename: &'a str,
    sessionid: &'a str,
    data_type: &'a str,
    ppid_argv: &'a str,
    argv: &'a str,
    tgid: &'a str,
    socket_pid: &'a str,
    dport: &'a str,
    dip: &'a str,
    socket_argv: &'a str,
    sid: &'a str,
    ppid: &'a str,
    sa_family: &'a str,
    pns: &'a str,
    file_path: &'a str,
}

#[derive(Debug, Serialize)]
struct Execve<'a> {
    pid_tree: &'a str,
    pgid_argv: &'a str,
    root_pns: &'a str,
    dip: &'a str,
    pid: &'a str,
    sessionid: &'a str,
    res: &'a str,
    uid: &'a str,
    pns: &'a str,
    tgid: &'a str,
    username: &'a str,
    ld_preload: &'a str,
    sid: &'a str,
    dport: &'a str,
    ppid_argv: &'a str,
    socket_argv: &'a str,
    sa_family: &'a str,
    nodename: &'a str,
    argv: &'a str,
    stdin: &'a str,
    socket_pid: &'a str,
    ssh: &'a str,
    exe: &'a str,
    exe_hash: &'a str,
    data_type: &'a str,
    pgid: &'a str,
    run_path: &'a str,
    sip: &'a str,
    timestamp: &'a str,
    ppid: &'a str,
    comm: &'a str,
    sport: &'a str,
    stdout: &'a str,
    tty: &'a str,
}

#[derive(Debug, Serialize)]
struct Dns<'a> {
    pid_tree: &'a str,
    nodename: &'a str,
    rcode: &'a str,
    sa_family: &'a str,
    sid: &'a str,
    pgid_argv: &'a str,
    ppid: &'a str,
    sessionid: &'a str,
    sip: &'a str,
    dip: &'a str,
    timestamp: &'a str,
    dport: &'a str,
    uid: &'a str,
    username: &'a str,
    comm: &'a str,
    sport: &'a str,
    exe_hash: &'a str,
    pgid: &'a str,
    ppid_argv: &'a str,
    pns: &'a str,
    data_type: &'a str,
    tgid: &'a str,
    argv: &'a str,
    root_pns: &'a str,
    pid: &'a str,
    query: &'a str,
    qr: &'a str,
    exe: &'a str,
    opcode: &'a str,
}

#[derive(Debug, Serialize)]
struct UpdateCred<'a> {
    res: &'a str,
    username: &'a str,
    ppid_argv: &'a str,
    pgid_argv: &'a str,
    argv: &'a str,
    uid: &'a str,
    nodename: &'a str,
    comm: &'a str,
    old_username: &'a str,
    sessionid: &'a str,
    exe_hash: &'a str,
    pid_tree: &'a str,
    sid: &'a str,
    data_type: &'a str,
    exe: &'a str,
    timestamp: &'a str,
    old_uid: &'a str,
    pns: &'a str,
    ppid: &'a str,
    pgid: &'a str,
    root_pns: &'a str,
    pid: &'a str,
    tgid: &'a str,
}

#[derive(Debug, Serialize)]
struct SyscallHook<'a> {
    timestamp: &'a str,
    hidden: &'a str,
    syscall_number: &'a str,
    data_type: &'a str,
    module_name: &'a str,
}

#[derive(Debug, Serialize)]
struct ProcFileHook<'a> {
    timestamp: &'a str,
    data_type: &'a str,
    hidden: &'a str,
    module_name: &'a str,
}

#[derive(Debug, Serialize)]
struct Link<'a> {
    timestamp: &'a str,
    sid: &'a str,
    exe: &'a str,
    ppid_argv: &'a str,
    pgid_argv: &'a str,
    pid_tree: &'a str,
    username: &'a str,
    data_type: &'a str,
    sessionid: &'a str,
    pid: &'a str,
    uid: &'a str,
    new_name: &'a str,
    pns: &'a str,
    ppid: &'a str,
    exe_hash: &'a str,
    argv: &'a str,
    pgid: &'a str,
    comm: &'a str,
    nodename: &'a str,
    run_path: &'a str,
    tgid: &'a str,
    old_name: &'a str,
    root_pns: &'a str,
}

#[derive(Debug, Serialize)]
struct Setsid<'a> {
    sessionid: &'a str,
    pid: &'a str,
    data_type: &'a str,
    exe: &'a str,
    pns: &'a str,
    ppid_argv: &'a str,
    nodename: &'a str,
    pgid_argv: &'a str,
    argv: &'a str,
    uid: &'a str,
    exe_hash: &'a str,
    ppid: &'a str,
    pid_tree: &'a str,
    comm: &'a str,
    root_pns: &'a str,
    username: &'a str,
    sid: &'a str,
    pgid: &'a str,
    tgid: &'a str,
    timestamp: &'a str,
}

#[derive(Debug, Serialize)]
struct Rename<'a> {
    new_name: &'a str,
    uid: &'a str,
    nodename: &'a str,
    pid_tree: &'a str,
    tgid: &'a str,
    root_pns: &'a str,
    username: &'a str,
    exe: &'a str,
    timestamp: &'a str,
    pgid_argv: &'a str,
    ppid: &'a str,
    ppid_argv: &'a str,
    sessionid: &'a str,
    argv: &'a str,
    comm: &'a str,
    run_path: &'a str,
    pns: &'a str,
    data_type: &'a str,
    pid: &'a str,
    old_name: &'a str,
    pgid: &'a str,
    sid: &'a str,
    exe_hash: &'a str,
}

#[derive(Debug, Serialize)]
struct Prctl<'a> {
    nodename: &'a str,
    tgid: &'a str,
    timestamp: &'a str,
    argv: &'a str,
    pid_tree: &'a str,
    exe_hash: &'a str,
    username: &'a str,
    option: &'a str,
    pid: &'a str,
    sessionid: &'a str,
    data_type: &'a str,
    uid: &'a str,
    new_name: &'a str,
    exe: &'a str,
    sid: &'a str,
    comm: &'a str,
    pns: &'a str,
    pgid_argv: &'a str,
    ppid_argv: &'a str,
    root_pns: &'a str,
    pgid: &'a str,
    ppid: &'a str,
}

#[derive(Debug, Serialize)]
struct MemfdCreate<'a> {
    nodename: &'a str,
    data_type: &'a str,
    pid: &'a str,
    argv: &'a str,
    sessionid: &'a str,
    tgid: &'a str,
    sid: &'a str,
    username: &'a str,
    exe_hash: &'a str,
    pid_tree: &'a str,
    root_pns: &'a str,
    comm: &'a str,
    exe: &'a str,
    pns: &'a str,
    uid: &'a str,
    ppid: &'a str,
    ppid_argv: &'a str,
    timestamp: &'a str,
    pgid_argv: &'a str,
    pgid: &'a str,
    fdname: &'a str,
    flags: &'a str,
}

#[derive(Debug, Serialize)]
struct Bind<'a> {
    pns: &'a str,
    timestamp: &'a str,
    root_pns: &'a str,
    ppid_argv: &'a str,
    sid: &'a str,
    nodename: &'a str,
    res: &'a str,
    pgid: &'a str,
    sessionid: &'a str,
    username: &'a str,
    exe_hash: &'a str,
    sa_family: &'a str,
    ppid: &'a str,
    comm: &'a str,
    pid: &'a str,
    sport: &'a str,
    pgid_argv: &'a str,
    data_type: &'a str,
    uid: &'a str,
    argv: &'a str,
    exe: &'a str,
    sip: &'a str,
    pid_tree: &'a str,
    tgid: &'a str,
}

#[derive(Debug, Serialize)]
struct LkmHidden<'a> {
    data_type: &'a str,
    module_name: &'a str,
    hidden: &'a str,
    timestamp: &'a str,
}

#[derive(Debug, Serialize)]
struct Ptrace<'a> {
    data_type: &'a str,
    username: &'a str,
    pgid_argv: &'a str,
    addr: &'a str,
    pid_tree: &'a str,
    argv: &'a str,
    sid: &'a str,
    comm: &'a str,
    pgid: &'a str,
    root_pns: &'a str,
    uid: &'a str,
    data: &'a str,
    exe_hash: &'a str,
    target_pid: &'a str,
    pns: &'a str,
    timestamp: &'a str,
    ppid: &'a str,
    ptrace_request: &'a str,
    sessionid: &'a str,
    pid: &'a str,
    nodename: &'a str,
    exe: &'a str,
    ppid_argv: &'a str,
    tgid: &'a str,
}

#[derive(Debug, Serialize)]
struct Connect<'a> {
    dport: &'a str,
    sport: &'a str,
    pid_tree: &'a str,
    dip: &'a str,
    ppid: &'a str,
    argv: &'a str,
    sip: &'a str,
    nodename: &'a str,
    comm: &'a str,
    sa_family: &'a str,
    pgid: &'a str,
    tgid: &'a str,
    username: &'a str,
    exe: &'a str,
    res: &'a str,
    uid: &'a str,
    sessionid: &'a str,
    sid: &'a str,
    pgid_argv: &'a str,
    root_pns: &'a str,
    connect_type: &'a str,
    data_type: &'a str,
    timestamp: &'a str,
    exe_hash: &'a str,
    pns: &'a str,
    pid: &'a str,
    ppid_argv: &'a str,
}

#[derive(Debug, Serialize)]
struct InterruptsHook<'a> {
    module_name: &'a str,
    hidden: &'a str,
    interrupts_number: &'a str,
    timestamp: &'a str,
    data_type: &'a str,
}

pub struct Parser {
    sender: Sender,
    user_cache: UsersCache,
    argv_cache: ArgvCache,
    pid_tree_cache: CLruCache<u32, String, FnvBuildHasher>,
    file_hash_cache: FileHashCache,
}

impl Parser {
    pub fn new(sender: Sender) -> Self {
        let mut ipv4_range: IpRange<Ipv4Net> = IpRange::new();
        let mut ipv6_range: IpRange<Ipv6Net> = IpRange::new();
        ipv4_range.add("127.0.0.1/8".parse().unwrap());
        ipv6_range.add("::1/128".parse().unwrap());
        ipv6_range.add("fe80::/10".parse().unwrap());
        Self {
            sender,
            user_cache: UsersCache::default(),
            argv_cache: ArgvCache::new(10240),
            pid_tree_cache: CLruCache::with_hasher(10240, FnvBuildHasher::default()),
            file_hash_cache: FileHashCache::new(10240),
        }
    }

    pub fn parse(&mut self, fields: Vec<&str>) -> Result<()> {
        match fields[1] {
            "603" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                if let Ok(pid) = fields[3].parse::<u32>() {
                    if fields[14] != "" && fields[14] != "-1" {
                        self.pid_tree_cache.put(pid, fields[14].to_string());
                    }
                }
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&LoadModule {
                    pgid_argv: &pgid_argv,
                    exe_hash: &exe_hash,
                    sessionid: fields[10],
                    pid: fields[3],
                    username: &username,
                    ko_file: fields[13],
                    nodename: fields[9],
                    run_path: fields[15],
                    uid: fields[0],
                    sid: fields[7],
                    comm: fields[8],
                    tgid: fields[6],
                    exe: fields[2],
                    pid_tree: fields[14],
                    pns: fields[11],
                    root_pns: fields[12],
                    ppid: fields[4],
                    pgid: fields[5],
                    timestamp: &timestamp,
                    data_type: fields[1],
                    argv: &argv,
                    ppid_argv: &ppid_argv,
                })
            }
            "602" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                let socket_argv = if let Ok(socket_pid) = fields[19].parse::<u32>() {
                    self.argv_cache.get(&socket_pid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&CreateFile {
                    sip: fields[16],
                    timestamp: &timestamp,
                    pgid: fields[5],
                    username: &username,
                    pid: fields[3],
                    exe_hash: &exe_hash,
                    comm: fields[8],
                    sport: fields[17],
                    pgid_argv: &pgid_argv,
                    pid_tree: &pid_tree,
                    root_pns: fields[12],
                    uid: fields[0],
                    exe: fields[2],
                    nodename: fields[9],
                    sessionid: fields[10],
                    data_type: fields[1],
                    ppid_argv: &ppid_argv,
                    argv: &argv,
                    tgid: fields[6],
                    socket_pid: fields[19],
                    dport: fields[15],
                    dip: fields[14],
                    socket_argv: &socket_argv,
                    sid: fields[7],
                    ppid: fields[4],
                    sa_family: fields[18],
                    pns: fields[11],
                    file_path: fields[13],
                })
            }
            "59" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                if let Ok(pid) = fields[3].parse::<u32>() {
                    if fields[24] != "" && fields[24] != "-1" {
                        self.pid_tree_cache.put(pid, fields[24].to_string());
                    }
                }
                if let Ok(pid) = fields[3].parse::<u32>() {
                    if fields[14] != "" && fields[14] != "-1" {
                        self.argv_cache.put(pid, fields[14].to_string());
                    }
                }
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                let socket_argv = if let Ok(socket_pid) = fields[26].parse::<u32>() {
                    self.argv_cache.get(&socket_pid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Execve {
                    pid_tree: fields[24],
                    pgid_argv: &pgid_argv,
                    root_pns: fields[12],
                    dip: fields[19],
                    pid: fields[3],
                    sessionid: fields[10],
                    res: fields[29],
                    uid: fields[0],
                    pns: fields[11],
                    tgid: fields[6],
                    username: &username,
                    ld_preload: fields[28],
                    sid: fields[7],
                    dport: fields[20],
                    ppid_argv: &ppid_argv,
                    socket_argv: &socket_argv,
                    sa_family: fields[23],
                    nodename: fields[9],
                    argv: fields[14],
                    stdin: fields[17],
                    socket_pid: fields[26],
                    ssh: fields[27],
                    exe: fields[2],
                    exe_hash: &exe_hash,
                    data_type: fields[1],
                    pgid: fields[5],
                    run_path: fields[15],
                    sip: fields[21],
                    timestamp: &timestamp,
                    ppid: fields[4],
                    comm: fields[8],
                    sport: fields[22],
                    stdout: fields[18],
                    tty: fields[25],
                })
            }
            "601" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Dns {
                    pid_tree: &pid_tree,
                    nodename: fields[9],
                    rcode: fields[21],
                    sa_family: fields[14],
                    sid: fields[7],
                    pgid_argv: &pgid_argv,
                    ppid: fields[4],
                    sessionid: fields[10],
                    sip: fields[17],
                    dip: fields[15],
                    timestamp: &timestamp,
                    dport: fields[16],
                    uid: fields[0],
                    username: &username,
                    comm: fields[8],
                    sport: fields[18],
                    exe_hash: &exe_hash,
                    pgid: fields[5],
                    ppid_argv: &ppid_argv,
                    pns: fields[11],
                    data_type: fields[1],
                    tgid: fields[6],
                    argv: &argv,
                    root_pns: fields[12],
                    pid: fields[3],
                    query: fields[13],
                    qr: fields[19],
                    exe: fields[2],
                    opcode: fields[20],
                })
            }
            "604" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let old_username = if let Ok(old_uid) = fields[14].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(old_uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                if let Ok(pid) = fields[3].parse::<u32>() {
                    if fields[13] != "" && fields[13] != "-1" {
                        self.pid_tree_cache.put(pid, fields[13].to_string());
                    }
                }
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&UpdateCred {
                    res: fields[15],
                    username: &username,
                    ppid_argv: &ppid_argv,
                    pgid_argv: &pgid_argv,
                    argv: &argv,
                    uid: fields[0],
                    nodename: fields[9],
                    comm: fields[8],
                    old_username: &old_username,
                    sessionid: fields[10],
                    exe_hash: &exe_hash,
                    pid_tree: fields[13],
                    sid: fields[7],
                    data_type: fields[1],
                    exe: fields[2],
                    timestamp: &timestamp,
                    old_uid: fields[14],
                    pns: fields[11],
                    ppid: fields[4],
                    pgid: fields[5],
                    root_pns: fields[12],
                    pid: fields[3],
                    tgid: fields[6],
                })
            }
            "701" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                self.sender.send(&SyscallHook {
                    timestamp: &timestamp,
                    hidden: fields[3],
                    syscall_number: fields[4],
                    data_type: fields[1],
                    module_name: fields[2],
                })
            }
            "700" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                self.sender.send(&ProcFileHook {
                    timestamp: &timestamp,
                    data_type: fields[1],
                    hidden: fields[3],
                    module_name: fields[2],
                })
            }
            "86" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Link {
                    timestamp: &timestamp,
                    sid: fields[7],
                    exe: fields[2],
                    ppid_argv: &ppid_argv,
                    pgid_argv: &pgid_argv,
                    pid_tree: &pid_tree,
                    username: &username,
                    data_type: fields[1],
                    sessionid: fields[10],
                    pid: fields[3],
                    uid: fields[0],
                    new_name: fields[15],
                    pns: fields[11],
                    ppid: fields[4],
                    exe_hash: &exe_hash,
                    argv: &argv,
                    pgid: fields[5],
                    comm: fields[8],
                    nodename: fields[9],
                    run_path: fields[13],
                    tgid: fields[6],
                    old_name: fields[14],
                    root_pns: fields[12],
                })
            }
            "112" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Setsid {
                    sessionid: fields[10],
                    pid: fields[3],
                    data_type: fields[1],
                    exe: fields[2],
                    pns: fields[11],
                    ppid_argv: &ppid_argv,
                    nodename: fields[9],
                    pgid_argv: &pgid_argv,
                    argv: &argv,
                    uid: fields[0],
                    exe_hash: &exe_hash,
                    ppid: fields[4],
                    pid_tree: &pid_tree,
                    comm: fields[8],
                    root_pns: fields[12],
                    username: &username,
                    sid: fields[7],
                    pgid: fields[5],
                    tgid: fields[6],
                    timestamp: &timestamp,
                })
            }
            "82" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Rename {
                    new_name: fields[15],
                    uid: fields[0],
                    nodename: fields[9],
                    pid_tree: &pid_tree,
                    tgid: fields[6],
                    root_pns: fields[12],
                    username: &username,
                    exe: fields[2],
                    timestamp: &timestamp,
                    pgid_argv: &pgid_argv,
                    ppid: fields[4],
                    ppid_argv: &ppid_argv,
                    sessionid: fields[10],
                    argv: &argv,
                    comm: fields[8],
                    run_path: fields[13],
                    pns: fields[11],
                    data_type: fields[1],
                    pid: fields[3],
                    old_name: fields[14],
                    pgid: fields[5],
                    sid: fields[7],
                    exe_hash: &exe_hash,
                })
            }
            "157" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Prctl {
                    nodename: fields[9],
                    tgid: fields[6],
                    timestamp: &timestamp,
                    argv: &argv,
                    pid_tree: &pid_tree,
                    exe_hash: &exe_hash,
                    username: &username,
                    option: fields[13],
                    pid: fields[3],
                    sessionid: fields[10],
                    data_type: fields[1],
                    uid: fields[0],
                    new_name: fields[14],
                    exe: fields[2],
                    sid: fields[7],
                    comm: fields[8],
                    pns: fields[11],
                    pgid_argv: &pgid_argv,
                    ppid_argv: &ppid_argv,
                    root_pns: fields[12],
                    pgid: fields[5],
                    ppid: fields[4],
                })
            }
            "356" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&MemfdCreate {
                    nodename: fields[9],
                    data_type: fields[1],
                    pid: fields[3],
                    argv: &argv,
                    sessionid: fields[10],
                    tgid: fields[6],
                    sid: fields[7],
                    username: &username,
                    exe_hash: &exe_hash,
                    pid_tree: &pid_tree,
                    root_pns: fields[12],
                    comm: fields[8],
                    exe: fields[2],
                    pns: fields[11],
                    uid: fields[0],
                    ppid: fields[4],
                    ppid_argv: &ppid_argv,
                    timestamp: &timestamp,
                    pgid_argv: &pgid_argv,
                    pgid: fields[5],
                    fdname: fields[13],
                    flags: fields[14],
                })
            }
            "49" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Bind {
                    pns: fields[11],
                    timestamp: &timestamp,
                    root_pns: fields[12],
                    ppid_argv: &ppid_argv,
                    sid: fields[7],
                    nodename: fields[9],
                    res: fields[16],
                    pgid: fields[5],
                    sessionid: fields[10],
                    username: &username,
                    exe_hash: &exe_hash,
                    sa_family: fields[13],
                    ppid: fields[4],
                    comm: fields[8],
                    pid: fields[3],
                    sport: fields[15],
                    pgid_argv: &pgid_argv,
                    data_type: fields[1],
                    uid: fields[0],
                    argv: &argv,
                    exe: fields[2],
                    sip: fields[14],
                    pid_tree: &pid_tree,
                    tgid: fields[6],
                })
            }
            "702" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                self.sender.send(&LkmHidden {
                    data_type: fields[1],
                    module_name: fields[2],
                    hidden: fields[3],
                    timestamp: &timestamp,
                })
            }
            "101" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                if let Ok(pid) = fields[3].parse::<u32>() {
                    if fields[17] != "" && fields[17] != "-1" {
                        self.pid_tree_cache.put(pid, fields[17].to_string());
                    }
                }
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Ptrace {
                    data_type: fields[1],
                    username: &username,
                    pgid_argv: &pgid_argv,
                    addr: fields[15],
                    pid_tree: fields[17],
                    argv: &argv,
                    sid: fields[7],
                    comm: fields[8],
                    pgid: fields[5],
                    root_pns: fields[12],
                    uid: fields[0],
                    data: fields[16],
                    exe_hash: &exe_hash,
                    target_pid: fields[14],
                    pns: fields[11],
                    timestamp: &timestamp,
                    ppid: fields[4],
                    ptrace_request: fields[13],
                    sessionid: fields[10],
                    pid: fields[3],
                    nodename: fields[9],
                    exe: fields[2],
                    ppid_argv: &ppid_argv,
                    tgid: fields[6],
                })
            }
            "42" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                let username = if let Ok(uid) = fields[0].parse::<u32>() {
                    match self.user_cache.get_user_by_uid(uid) {
                        Some(n) => n.name().to_str().unwrap_or_default().to_owned(),
                        None => "-3".to_string(),
                    }
                } else {
                    "-3".to_string()
                };
                let exe_hash = if fields[2] != "-1" && fields[2] != "" {
                    self.file_hash_cache.get(fields[2])
                } else {
                    "-3".to_string()
                };
                let pid_tree = if let Ok(pid) = fields[3].parse::<u32>() {
                    let pid_tree = match self.pid_tree_cache.get(&pid) {
                        Some(t) => t,
                        None => "-3",
                    };
                    pid_tree
                } else {
                    "-3"
                };
                let argv = if let Ok(pid) = fields[3].parse::<u32>() {
                    self.argv_cache.get(&pid)
                } else {
                    "-3".to_string()
                };
                let pgid_argv = if let Ok(pgid_id) = fields[5].parse::<u32>() {
                    self.argv_cache.get(&pgid_id)
                } else {
                    "-3".to_string()
                };
                let ppid_argv = if let Ok(ppid) = fields[4].parse::<u32>() {
                    self.argv_cache.get(&ppid)
                } else {
                    "-3".to_string()
                };
                self.sender.send(&Connect {
                    dport: fields[16],
                    sport: fields[18],
                    pid_tree: &pid_tree,
                    dip: fields[15],
                    ppid: fields[4],
                    argv: &argv,
                    sip: fields[17],
                    nodename: fields[9],
                    comm: fields[8],
                    sa_family: fields[14],
                    pgid: fields[5],
                    tgid: fields[6],
                    username: &username,
                    exe: fields[2],
                    res: fields[19],
                    uid: fields[0],
                    sessionid: fields[10],
                    sid: fields[7],
                    pgid_argv: &pgid_argv,
                    root_pns: fields[12],
                    connect_type: fields[13],
                    data_type: fields[1],
                    timestamp: &timestamp,
                    exe_hash: &exe_hash,
                    pns: fields[11],
                    pid: fields[3],
                    ppid_argv: &ppid_argv,
                })
            }
            "703" => {
                let timestamp = Clock::now_since_epoch().as_secs().to_string();
                self.sender.send(&InterruptsHook {
                    module_name: fields[2],
                    hidden: fields[3],
                    interrupts_number: fields[4],
                    timestamp: &timestamp,
                    data_type: fields[1],
                })
            }
            _ => {
                warn!("Datatype does not support:{:?}", fields);
                Ok(())
            }
        }
    }
}
